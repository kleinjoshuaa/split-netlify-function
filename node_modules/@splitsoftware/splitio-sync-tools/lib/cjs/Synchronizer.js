"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Synchronizer = void 0;
const tslib_1 = require("tslib");
const splitApi_1 = require("@splitsoftware/splitio-commons/cjs/services/splitApi");
const SegmentsSynchronizer_1 = require("./synchronizers/SegmentsSynchronizer");
const SplitsSynchronizer_1 = require("./synchronizers/SplitsSynchronizer");
const synchronizerStorage_1 = require("./storages/synchronizerStorage");
const eventsSubmitter_1 = require("./submitters/eventsSubmitter");
const impressionsSubmitter_1 = require("./submitters/impressionsSubmitter");
const impressionObserverSS_1 = require("@splitsoftware/splitio-commons/cjs/trackers/impressionObserver/impressionObserverSS");
const ImpressionCountsCacheInMemory_1 = require("@splitsoftware/splitio-commons/cjs/storages/inMemory/ImpressionCountsCacheInMemory");
const telemetryTracker_1 = require("@splitsoftware/splitio-commons/cjs/trackers/telemetryTracker");
const impressionCountsSubmitter_1 = require("./submitters/impressionCountsSubmitter");
const settings_1 = require("./settings");
const inputValidation_1 = require("@splitsoftware/splitio-commons/cjs/utils/inputValidation");
const InMemoryStorage_1 = require("@splitsoftware/splitio-commons/cjs/storages/inMemory/InMemoryStorage");
const telemetrySubmitter_1 = require("./submitters/telemetrySubmitter");
const uniqueKeysSubmitter_1 = require("./submitters/uniqueKeysSubmitter");
/**
 * Main class to handle the Synchronizer execution.
 */
class Synchronizer {
    /**
     * @param  {ISynchronizerSettings} config  Configuration object used to instantiates the Synchronizer.
     */
    constructor(config) {
        this._observer = (0, impressionObserverSS_1.impressionObserverSSFactory)();
        const settings = (0, settings_1.synchronizerSettingsValidator)(config);
        if (!(0, inputValidation_1.validateApiKey)(settings.log, settings.core.authorizationKey)) {
            throw new Error('Unable to initialize Synchronizer task: invalid SDK key.');
        }
        this.settings = settings;
        /**
         * The Split's HTTPclient, required to make the requests to the API.
         */
        this._splitApi = (0, splitApi_1.splitApiFactory)(this.settings, { getFetch: Synchronizer._getFetch }, (0, telemetryTracker_1.telemetryTrackerFactory)() // no-op telemetry tracker
        );
    }
    /**
     * Function to check the health status of Split APIs (SDK and Events services).
     *
     * @returns {Promise<boolean>}
     */
    _checkEndpointHealth() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return yield Promise.all([
                this._splitApi.getSdkAPIHealthCheck(),
                this._splitApi.getEventsAPIHealthCheck(),
            ]).then((results) => results.every((result) => result));
        });
    }
    /**
     * Function to set a storage.
     *
     * @returns {Promise<void>} A Promise that resolves when the storage is ready. It can reject if the storage is not properly configured (e.g., invalid wrapper) or the wrapper fails to connect.
     */
    initializeStorage() {
        return new Promise((res, rej) => {
            // @ts-ignore
            this._storage = (0, synchronizerStorage_1.synchronizerStorageFactory)(this.settings, (error) => error ? rej(error) : res());
        }).catch((error) => {
            throw new Error(`Error when connecting storage. ${error}`);
        });
    }
    /**
     * Function to set all the required Synchronizers.
     */
    initializeSynchronizers() {
        // @todo: Add Cli paramater to define impressionsMode.
        const countsCache = this.settings.sync.impressionsMode === 'OPTIMIZED' ?
            new ImpressionCountsCacheInMemory_1.ImpressionCountsCacheInMemory() :
            undefined;
        this._segmentsSynchronizer = new SegmentsSynchronizer_1.SegmentsSynchronizer(this._splitApi.fetchSegmentChanges, this.settings, this._storage.segments);
        this._splitsSynchronizer = new SplitsSynchronizer_1.SplitsSynchronizer(this._splitApi.fetchSplitChanges, this.settings, this._storage.splits, this._storage.segments, 
        // @ts-ignore
        (0, InMemoryStorage_1.InMemoryStorageFactory)({ settings: this.settings }), 
        // @ts-ignore
        (0, InMemoryStorage_1.InMemoryStorageFactory)({ settings: this.settings }));
        this._eventsSubmitter = (0, eventsSubmitter_1.eventsSubmitterFactory)(this.settings.log, this._splitApi.postEventsBulk, this._storage.events, this.settings.scheduler.eventsPerPost, this.settings.scheduler.maxRetries);
        this._impressionsSubmitter = (0, impressionsSubmitter_1.impressionsSubmitterFactory)(this.settings.log, this._splitApi.postTestImpressionsBulk, this._storage.impressions, this._observer, this.settings.scheduler.impressionsPerPost, this.settings.scheduler.maxRetries, countsCache);
        this._impressionCountsSubmitter = (0, impressionCountsSubmitter_1.impressionCountsSubmitterFactory)(this.settings.log, this._splitApi.postTestImpressionsCount, this._storage.impressionCounts, // ATM we are ignoring counts from `countsCache` and only sending the ones from the storage.
        this.settings.scheduler.maxRetries, countsCache);
        this._uniqueKeysSubmitter = (0, uniqueKeysSubmitter_1.uniqueKeysSubmitterFactory)(this.settings.log, this._splitApi.postUniqueKeysBulkSs, this._storage.uniqueKeys, this.settings.scheduler.maxRetries);
        this._telemetrySubmitter = (0, telemetrySubmitter_1.telemetrySubmitterFactory)(this.settings.log, this._splitApi, this._storage.telemetry);
    }
    /**
     * Function to prepare for sync tasks. Checks for Fetch API availability and initialize Syncs and Storages.
     *
     * @returns {Promise<void>} A promise that resolves if the synchronizer is ready to execute. It rejects with an error,
     * for example, if the Fetch API is not available, Split API is not responding, or Storage connection fails.
     */
    preExecute() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const log = this.settings.log;
            if (!Synchronizer._getFetch())
                throw new Error('Global Fetch API is not available');
            log.info('Synchronizer: Execute');
            const areAPIsReady = yield this._checkEndpointHealth();
            if (!areAPIsReady)
                throw new Error('Health check of Split API endpoints failed');
            log.info('Split API ready');
            yield this.initializeStorage();
            log.info('Storage setup ready');
            this.initializeSynchronizers();
        });
    }
    /**
     * Function to wrap actions to perform after the sync tasks have been executed.
     * Currently, it disconects from the Storage.
     *
     * @returns {Promise<void>} A promise that resolves if the synchronizer has successfully disconnected from the storage. Otherwise, it rejects with an error.
     */
    postExecute() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            try {
                yield this._storage.destroy();
            }
            catch (error) {
                throw new Error(`Error when disconnecting storage. ${error}`);
            }
        });
    }
    /**
     * Method to start the Synchronizer execution.
     *
     * @param {Function?} cb Optional error-first callback to be invoked when the synchronization ends. The callback will be invoked with an error as first argument if the synchronization fails.
     * @returns {Promise<boolean>}
     */
    execute(cb) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            try {
                // @ts-ignore @TODO define synchronizerMode config param
                const mode = this.settings.scheduler.synchronizerMode || 'MODE_RUN_ALL';
                yield this.preExecute();
                let errorMessage;
                if (mode === 'MODE_RUN_ALL' || mode === 'MODE_RUN_FEATURE_FLAGS_AND_SEGMENTS') {
                    if (!(yield this.executeSplitsAndSegments(false)))
                        errorMessage = 'Feature flags and/or segments synchronization failed';
                }
                if (mode === 'MODE_RUN_ALL' || mode === 'MODE_RUN_EVENTS_AND_IMPRESSIONS') {
                    if (!(yield this.executeImpressionsAndEvents(false)))
                        errorMessage = 'Impressions and/or events synchronization failed';
                }
                // Disconnect from storage before throwing synchronization error
                yield this.postExecute();
                if (errorMessage)
                    throw new Error(errorMessage);
                this.settings.log.info('Synchronizer: Execution ended successfully');
                cb && cb();
                return true;
            }
            catch (error) {
                this.settings.log.error(`Synchronizer: Execution ended unsuccessfully with error: ${error}`);
                cb && cb(error);
                return false;
            }
        });
    }
    // @TODO remove standalone param for cleaner code
    /**
     * Function to wrap the execution of the feature flags and segments synchronizers.
     *
     * @param {boolean} standalone  Flag to determine the function requires the preExecute conditions.
     * @returns {Promise<boolean>} A promise that resolves to a boolean value indicating if feature flags and segments were successfully fetched and stored.
     */
    executeSplitsAndSegments(standalone = true) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (standalone)
                yield this.preExecute();
            // @TODO optimize SplitChangesUpdater to reduce storage operations ("inMemoryOperation" mode)
            const isSplitsSyncSuccessfull = yield this._splitsSynchronizer.getSplitChanges();
            this.settings.log.debug(`Feature flags Synchronizer task: ${isSplitsSyncSuccessfull ? 'Successful' : 'Unsuccessful'}`);
            const isSegmentsSyncSuccessfull = yield this._segmentsSynchronizer.getSegmentsChanges();
            this.settings.log.debug(`Segments Synchronizer task: ${isSegmentsSyncSuccessfull ? 'Successful' : 'Unsuccessful'}`);
            if (standalone)
                yield this.postExecute();
            return isSplitsSyncSuccessfull && isSegmentsSyncSuccessfull;
        });
    }
    /**
     * Function to wrap the execution of the Impressions and Event's synchronizers.
     *
     * @param {boolean} standalone  Flag to determine the function requires the preExecute conditions.
     * @returns {Promise<boolean>} A promise that resolves to a boolean value indicating if impressions and events were successfully popped from the storage and sent to Split.
     */
    executeImpressionsAndEvents(standalone = true) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const log = this.settings.log;
            if (standalone)
                yield this.preExecute();
            const isEventsSyncSuccessfull = yield this._eventsSubmitter();
            log.debug(`Events Synchronizer task: ${isEventsSyncSuccessfull ? 'Successful' : 'Unsuccessful'}`);
            const isImpressionsSyncSuccessfull = yield this._impressionsSubmitter();
            log.debug(`Impressions Synchronizer task: ${isImpressionsSyncSuccessfull ? 'Successful' : 'Unsuccessful'}`);
            let isSyncSuccessfull = isEventsSyncSuccessfull && isImpressionsSyncSuccessfull;
            if (this._impressionCountsSubmitter) {
                const isImpressionCountsSyncSuccessfull = yield this._impressionCountsSubmitter();
                isSyncSuccessfull = isSyncSuccessfull && isImpressionCountsSyncSuccessfull;
                log.debug(`ImpressionCounts Synchronizer task: ${isImpressionCountsSyncSuccessfull ? 'Successful' : 'Unsuccessful'}`);
            }
            if (this._uniqueKeysSubmitter) {
                const isUniqueKeysSyncSuccessfull = yield this._uniqueKeysSubmitter();
                isSyncSuccessfull = isSyncSuccessfull && isUniqueKeysSyncSuccessfull;
                log.debug(`UniqueKeys Synchronizer task: ${isUniqueKeysSyncSuccessfull ? 'Successful' : 'Unsuccessful'}`);
            }
            if (this._telemetrySubmitter) {
                const isTelemetrySyncSuccessfull = yield this._telemetrySubmitter();
                // if telemetry sync fails, we don't return false, since it's not a critical operation
                log.debug(`Telemetry Synchronizer task: ${isTelemetrySyncSuccessfull ? 'Successful' : 'Unsuccessful'}`);
            }
            return isSyncSuccessfull;
        });
    }
    /**
     * Function to set the Fetch function to perform the requests. It can be provided through
     * the NPM package, or fallbacks to the global Fetch function if available. In case
     * there is no fetch globally, returns undefined.
     *
     * @returns {IFetch|undefined}
     */
    static _getFetch() {
        let _fetch;
        try {
            _fetch = require('node-fetch');
            // Handle node-fetch issue https://github.com/node-fetch/node-fetch/issues/1037
            if (typeof _fetch !== 'function')
                _fetch = _fetch.default;
        }
        catch (e) {
            // Try to access global fetch if `node-fetch` package couldn't be imported (e.g., not in a Node environment)
            // eslint-disable-next-line no-undef
            _fetch = typeof fetch === 'function' ? fetch : undefined;
        }
        return _fetch;
    }
}
exports.Synchronizer = Synchronizer;
