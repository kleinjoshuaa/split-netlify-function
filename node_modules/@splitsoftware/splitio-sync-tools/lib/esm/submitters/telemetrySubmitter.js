import { __awaiter } from "tslib";
import { metadataToHeaders } from './utils';
import { _Map } from '@splitsoftware/splitio-commons/esm/utils/lang/maps';
/**
 * Function factory that returns a Telemetry Submitter, a function that retrieves configs and usage stats
 * (latencies and exceptions) from the telemetry storage, and submits them to the Split cloud.
 * The function returns a promise that never rejects, and resolves to true or false if the operation success or not.
 *
 * @param {ILogger}              logger          The Synchronizer's Logger.
 * @param {ISplitApi}            splitApi        The Split's HTTPClient API to perform the POST request.
 * @param {ITelemetryCacheAsync} telemetryCache  The Telemetry storage Cache from where to retrieve data.
 * @returns {() => Promise<boolean>}
 */
export function telemetrySubmitterFactory(logger, splitApi, telemetryCache) {
    function buildUsageStats() {
        return __awaiter(this, void 0, void 0, function* () {
            const latencies = yield telemetryCache.popLatencies();
            const exceptions = yield telemetryCache.popExceptions();
            const result = new _Map();
            latencies.forEach((latency, metadata) => {
                result.set(metadata, { mL: latency });
            });
            exceptions.forEach((exception, metadata) => {
                const usageStats = result.get(metadata);
                if (usageStats) {
                    usageStats.mE = exception;
                }
                else {
                    result.set(metadata, { mE: exception });
                }
            });
            return result;
        });
    }
    function synchronizeUsageStats() {
        return __awaiter(this, void 0, void 0, function* () {
            let usageStats;
            try {
                usageStats = yield buildUsageStats();
            }
            catch (e) {
                logger.error(`An error occurred when retrieving telemetry usage stats from storage: ${e}`);
                return false;
            }
            try {
                // Submit usage stats
                const requests = [];
                usageStats.forEach((usage, metadata) => {
                    // No retries for telemetry
                    requests.push(splitApi.postMetricsUsage(JSON.stringify(usage), metadataToHeaders(JSON.parse(metadata))));
                });
                yield Promise.all(requests);
                return true;
            }
            catch (e) {
                logger.error(`An error occurred when submitting telemetry usage stats: ${e}`);
                return false;
            }
        });
    }
    function synchronizeConfigs() {
        return __awaiter(this, void 0, void 0, function* () {
            let configs;
            try {
                configs = yield telemetryCache.popConfigs();
            }
            catch (e) {
                logger.error(`An error occurred when retrieving telemetry configs from storage: ${e}`);
                return false;
            }
            try {
                // Submit configs
                const requests = [];
                configs.forEach((config, metadata) => {
                    // No retries for telemetry
                    requests.push(splitApi.postMetricsConfig(JSON.stringify(config), metadataToHeaders(JSON.parse(metadata))));
                });
                yield Promise.all(requests);
                return true;
            }
            catch (e) {
                logger.error(`An error occurred when submitting telemetry configs: ${e}`);
                return false;
            }
        });
    }
    return function () {
        return synchronizeUsageStats().then((usageStatsSuccess) => {
            return synchronizeConfigs().then((configsSuccess) => {
                return usageStatsSuccess && configsSuccess;
            });
        });
    };
}
