import { __awaiter } from "tslib";
import { fromImpressionCountsCollector } from '@splitsoftware/splitio-commons/esm/sync/submitters/impressionCountsSubmitter';
import { submitterFactory } from './submitter';
import { _Map } from '@splitsoftware/splitio-commons/esm/utils/lang/maps';
// Merge impressions counts objects
function merge(counts1, counts2) {
    const merged = new _Map(counts1.pf.map((count) => [count.f + count.m, count]));
    counts2.pf.forEach((count) => {
        const key = count.f + count.m;
        if (merged.has(key))
            merged.get(key).rc += count.rc;
        else
            merged.set(key, count);
    });
    const pf = [];
    merged.forEach((count) => pf.push(count));
    return { pf };
}
export function impressionCountsSubmitterFactory(logger, postClient, impressionCountsCache, maxRetries, impressionCountsCacheInMemory) {
    function getPayload() {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield impressionCountsCache.getImpressionsCount();
            // Get impression counts from the in-memory cache available when Synchronizer runs in OPTIMIZED impressions mode
            // and merge with the ones from pluggable storage.
            if (impressionCountsCacheInMemory) {
                const impressionCountsData = impressionCountsCacheInMemory.pop();
                const memoryCounts = Object.keys(impressionCountsData).length > 0 ?
                    fromImpressionCountsCollector(impressionCountsData) :
                    undefined;
                if (memoryCounts)
                    result = result ? merge(result, memoryCounts) : memoryCounts;
            }
            return result;
        });
    }
    return submitterFactory(logger, postClient, getPayload, 'impression counts', maxRetries);
}
