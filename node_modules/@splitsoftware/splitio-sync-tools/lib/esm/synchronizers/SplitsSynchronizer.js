import { __awaiter } from "tslib";
import { splitChangesFetcherFactory } from '@splitsoftware/splitio-commons/esm/sync/polling/fetchers/splitChangesFetcher';
import { splitChangesUpdaterFactory } from '@splitsoftware/splitio-commons/esm/sync/polling/updaters/splitChangesUpdater';
/**
 * Class that manages the synchronization of feature flags.
 */
export class SplitsSynchronizer {
    /**
     * @param {IFetchSplitChanges}   splitFetcher     The SplitChanges fetcher from Split API.
     * @param {ISettings}            settings         The Synchronizer's settings.
     * @param {ISplitsCacheAsync}    splitsStorage    The reference to the current Split Storage.
     * @param {ISegmentsCacheAsync}  segmentsStorage  The reference to the current Cache Storage.
     * @param {IStorageSync}  inMemoryStorage  The reference to the current Cache Storage.
     * @param {IStorageSync}  inMemoryStorageSnapshot  The reference to the current Cache Storage.
     */
    constructor(splitFetcher, settings, splitsStorage, segmentsStorage, inMemoryStorage, inMemoryStorageSnapshot) {
        this._splitsStorage = splitsStorage;
        this._segmentsStorage = segmentsStorage;
        this._settings = settings;
        this._fetcher = splitChangesFetcherFactory(splitFetcher);
        this._splitUpdater = undefined;
        this._inMemoryStorage = inMemoryStorage;
        this._inMemoryStorageSnapshot = inMemoryStorageSnapshot;
    }
    /**
     * Function to use the SplitUpdater, in order to fetch and store feature flags from the BE.
     *
     * @returns {Promise<boolean>}
     */
    getSplitChanges() {
        this._splitUpdater = splitChangesUpdaterFactory(this._settings.log, this._fetcher, this._splitsStorage, this._segmentsStorage, this._settings.sync.__splitFiltersValidation);
        return this._splitUpdater();
    }
    /**
     * Method to retrieve feature flags from external Storage and transfer to local InMemory cache.
     *
     * @param {SplitsCacheInMemory} splitCacheInMemory  Reference to the local InMemoryCache.
     */
    getDataFromStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            const _splitsList = [];
            try {
                const splits = yield this._splitsStorage.getAll();
                splits.forEach((split) => {
                    _splitsList.push([split.name, split]);
                });
                this._inMemoryStorage.splits.addSplits(_splitsList);
                this._inMemoryStorageSnapshot.splits.addSplits(_splitsList);
                const registeredSegments = yield this._segmentsStorage.getRegisteredSegments();
                if (registeredSegments.length > 0) {
                    this._inMemoryStorage.segments.registerSegments(registeredSegments);
                    this._inMemoryStorageSnapshot.segments.registerSegments(registeredSegments);
                }
                const changeNumber = yield this._splitsStorage.getChangeNumber();
                this._inMemoryStorage.splits.setChangeNumber(changeNumber);
                this._inMemoryStorageSnapshot.splits.setChangeNumber(changeNumber);
            }
            catch (error) {
                this._settings.log.error(`Feature flags InMemory synchronization: Error when retreving data from external Storage. Error: ${error}`);
            }
        });
    }
    /**
     * Function to store feature flags from InMemory cache to the provided external Storage.
     */
    putDataToStorage() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const snapshotChangeNumber = (_a = this._inMemoryStorageSnapshot) === null || _a === void 0 ? void 0 : _a.splits.getChangeNumber();
                const changeNumber = (_b = this._inMemoryStorage) === null || _b === void 0 ? void 0 : _b.splits.getChangeNumber();
                if (snapshotChangeNumber === changeNumber)
                    return;
                const diffResult = yield this.processDifferences();
                if (diffResult > 0)
                    this._settings.log.info(`Removed ${diffResult} feature flags from storage`);
                const splits = this._inMemoryStorage.splits.getAll() || [];
                if (splits.length > 0) {
                    const splitsToStore = [];
                    for (let i = 0; i < splits.length; i++) {
                        const split = splits[i];
                        const { name, changeNumber } = split;
                        const oldSplitDefinition = this._inMemoryStorageSnapshot.splits.getSplit(name);
                        if (split) {
                            // If the feature flag doesn't exists.
                            if (!oldSplitDefinition) {
                                splitsToStore.push([name, split]);
                                continue;
                            }
                            // If the feature flag exists and needs to be updated.
                            if (oldSplitDefinition.changeNumber !== changeNumber) {
                                splitsToStore.push([name, split]);
                                continue;
                            }
                        }
                    }
                    yield this._splitsStorage.addSplits(splitsToStore);
                }
                yield this._splitsStorage.setChangeNumber(changeNumber);
                const registeredSegments = this._inMemoryStorage.segments.getRegisteredSegments();
                // @todo: Update segment definitions and change number
                if (registeredSegments.length > 0)
                    yield this._segmentsStorage.registerSegments(registeredSegments);
            }
            catch (error) {
                this._settings.log.error(`Feature flags InMemory synchronization: Error when storing data to external Storage. Error: ${error}`);
            }
        });
    }
    /**
     * Function to use the InMemoryCache to execute the SplitUpdater to fetch and store feature flags
     * from the BE.
     *
     * @returns {Promise<boolean>}
     */
    getSplitChangesInMemory() {
        return __awaiter(this, void 0, void 0, function* () {
            this._splitUpdater = splitChangesUpdaterFactory(this._settings.log, this._fetcher, this._inMemoryStorage.splits, this._inMemoryStorage.segments, this._settings.sync.__splitFiltersValidation);
            try {
                this._settings.log.info('InMemoryOperation config enabled.');
                yield this.getDataFromStorage();
                const res = yield this._splitUpdater();
                if (!res) {
                    return Promise.resolve(false);
                }
                yield this.putDataToStorage();
                return res;
            }
            catch (error) {
                this._settings.log.error(`Error executing feature flags synchronization with InMemory cache. ${error}`);
                return Promise.resolve(false);
            }
        });
    }
    /**
     * Function to compare an inital InMemory cache snapshot with the updated InMemory cache after synchronization.
     * It will calculate differences, removing feature flags that are no longer required and updating the ones with new data.
     *
     * @returns {any}
     */
    processDifferences() {
        return __awaiter(this, void 0, void 0, function* () {
            let deletedAmount = 0;
            const oldSplitsKeys = this._inMemoryStorageSnapshot.splits.getSplitNames() || [];
            const newSplitsKeys = this._inMemoryStorage.splits.getSplitNames() || [];
            const splitKeysToRemove = [];
            oldSplitsKeys.forEach((key) => {
                const splitName = key;
                if (!newSplitsKeys.some((k) => k === splitName)) {
                    splitKeysToRemove.push(splitName);
                    deletedAmount++;
                }
            });
            yield this._splitsStorage.removeSplits(splitKeysToRemove);
            return deletedAmount;
        });
    }
}
